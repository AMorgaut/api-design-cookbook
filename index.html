<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
    <title>Web API Design Cookbook</title>
    <script class='remove'>
      var respecConfig = {
          specStatus: "unofficial",
          shortName:  "api-design",
          editors: [
            {
              name:       "Robin Berjon",
              url:        "http://berjon.com/",
              company:    "Robineko",
              companyURL: "http://robineko.com/"
            }
          ],
          edDraftURI:   "http://darobin.github.com/api-design-cookbook/",
          copyrightStart: 2011,
          noIDLIn:      true,
          wg:           ["Device APIs Working Group", "Web Applications (WebApps) Working Group"],
          wgURI:        ["http://www.w3.org/2009/dap/", "http://www.w3.org/2008/webapps/"],
          wgPublicList: "public-device-apis",
          wgPatentURI:  ["http://www.w3.org/2004/01/pp-impl/43696/status", "http://www.w3.org/2004/01/pp-impl/42538/status"]
      };
    </script>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' class='remove' async></script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document captures common practices in designing APIs that fit well into the Web platform as
        a whole, using WebIDL [[!WEBIDL]].
      </p>
    </section>
    <section id='sotd'>
      <p>
        As it currently stands, this document is nothing more than a proposal from its editor, with no
        backing implied or otherwise from any other party.
      </p>
    </section>
    <section>
      <h2>Introduction</h2>
      <p>
        Over a relatively short period of time the number of different APIs being created for use on the
        Web has grown at a sustained pace. In working on these interfaces, many in the community discuss
        the benefits of certain approaches over others and reach agreement as to the preferred solution when
        facing a given problem.
      </p>
      <p>
        Keeping track of all these gems is however difficult given the volume of work being carried on
        in parallel and the sometimes disjointed nature of the groups involved. As a result, it can take
        a long while and many arguments repeated almost identically before a good solution becomes common.
      </p>
      <p>
        What's more, it is altogether too rare to garner feedback from developers who are actually using
        these features in their day-to-day work. Because of this, several APIs have shipped with issues
        that could have been caught earlier on in the process. This document therefore also endeavours
        to elicit feedback from developers in order to make it more readily available to API designers.
      </p>
      <p>
        The goal of this document is to capture such ideas as they appear and accrete them over time so as
        to constitute a repository of knowledge on this topic. As a guide it does not however attempt to
        supplant editors' brains in making decisions as to how to design their APIs, and consequently one
        must keep in mind that the reasoning behind a specific recommendation is often more important than
        its result. Furthermore, in some cases there may not be a single consensual best approach, and
        editors will need to understand the tradeoffs involved in order to pick what works for them amongst
        a set of options.
      </p>
    </section>
    <section>
      <h2>Basics</h2>
      <p>
        This section covers the very basics of API creation for the Web platform. If you are familiar with
        the APIs found there, you might wish to simply skim the titles.
      </p>
      <section>
        <h2>Casing</h2>
        <p>
          Casing is relatively coherent across the platform, and if you are familiar with JavaScript development
          it should come to you rather naturally.
        </p>
        <p>
          Interfaces, dictionaries, exceptions, and callbacks all use “CamelCase”. That is to say no underscores are used
          and the first letter of every word is in uppercase. The rules when one of those words is an acronym
          are not necessarily well established — follow your instinct (or try to avoid acronyms).
        </p>
        <pre class='example'>
          FascinatingDocument
          Node
          SomethingBadHappened
          XMLHttpRequest
        </pre>
        <p>
          Both attributes and methods use “pascalCase” also known as “interCaps”. Which is to say that the first
          letter is lowercase, no underscores are used, and all the following logical words in the name
          start with an uppercase letter.
        </p>
        <pre class='example'>
          obj.thisIsAnAttribute
          obj.simple
          obj.doSomethingNow()
          obj.run()
        </pre>
        <p>
          Constants are all uppercase, with logical words separated by underscores. Families of constants tend
          to have common suffixes. Please note that constants are decreasingly used and that it is likely you 
          will not be having recourse to this construct very much (see <a href='#numerical-constants'>Don't 
          Use Numerical Constants</a>).
        </p>
        <pre class='example'>
          REALLY_STUPID_ERROR
          PASTA_SAUCE_TYPE
        </pre>
        <p>
          Events are a bit special and for historical reasons have somewhat more convoluted rules. The interface 
          that represents a specific event will follow the general rules for interfaces, ending with <code>Event</code>. 
          But the event name will be all lowercase and with no underscores. Likewise, the <code>on*</code> event 
          attribute will be the event name (all lowercase and glued together) simply prefixed with “<code>on</code>”.
        </p>
        <pre class='example'>
          SomethingHappenedEvent
          obj.addEventListener("somethinghappened", handler, false);
          el.onsomethinghappened = handler;
        </pre>
      </section>
      <section>
        <h2>Using attributes</h2>
        <p>
          It is not always obvious when one should use an attribute rather than a method. The basic rule is simple:
          use attributes as often as possible.
        </p>
        <p>
          Never use <code>getFoo()</code>/<code>setFoo()</code> accessor pairs unless it is very clear that these are
          operations that have strong effects beyond just changing the property of the object. If you wish your interface
          to also be usable in a language other than JavaScript and for which such accessors tend to be needed, the bindings
          for that language can naturally generate the accessor pair. Don't do this:
        </p>
        <pre class='illegal-example' title='Bad usage'>
          var len = obj.getLength();
          arr.setLength(num);
        </pre>
        <p>
          But rather:
        </p>
        <pre class='example'>
          var len = obj.length;
          arr.length = num;
        </pre>
        <p>
          Beyond operations that obviously require a method (that take parameters, return a computed value, carry out
          an action, etc.) there are specific cases in which what might at first seem like a candidate for being
          an attribute is best handled as a method:
        </p>
        <dl>
          <dt>Modifies the value</dt>
          <dd>
            In some cases there may be relations between objects such that when one is set as the value of another
            it needs to be updated to reflect its end of the relationship as well. For instance, when setting
            <code class='highlight'>objA.child = objB</code> it may be necessary to set <code>objB.parent</code>
            to <code>objA</code> behind the scenes. Such side effects call for a method: <code>objA.setChild(objB)</code>.
          </dd>
          <dt>Asynchronous access</dt>
          <dd>
            In some instances, an object may be available but it is best if some of its fields are only loaded 
            lazily because they require time to compute. The canonical example is the size of a file. If processing
            objects representing files, making the size of each file available immediately will be costly, and 
            acquiring it synchronously upon attribute access would lead to poor performance (those <code>stat</code>
            calls are not cheap). In such cases it is best to make the accessor an asynchronous method that is
            passed a callback such as <code class='highlight'>someFile.size(function (bytes) { … })</code> 
            (or, if there are many such properties on the object, have a single call to load them all, for instance
            <code class='highlight'>someFile.stat(function (info) { … })</code>).
          </dd>
        </dl>
      </section>
      <section>
        <h2>When To Be Asynchronous</h2>
        <p>
          The Web platform's runtime model is based on a single-threaded event loop. Because of that, any time
          a method requires even a little bit of time to run, it blocks the thread, and therefore the execution
          of anything else on the page — leading to bad user experience.
        </p>
        <p>
          Example of operations that can take a while to complete include reading from the network, accessing the
          disk, performing a database search, or waking a sensor up.
        </p>
        <p>
          Another case in which asynchronous operations are required is for all security entry points. Some operations
          (e.g. obtaining the device's physical location) can require the user agent to obtain the user's permission.
          If that were to be done synchronously, the entire application would freeze while the user makes her decision.
          This is undesirable in terms of user experience, but it also a bad security model. The user needs to have
          all the time she wants in order to make such decisions and should not feel pressured by a frozen application
          (people make bad security decisions when they want to get something done).
        </p>
        <p>
          It can seem tempting to make methods either synchronous or asynchronous at the developer's discretion.
          The simple answer to that is: don't. The result can be catastrophic: for instance, while in development 
          a method that has to interact with a remote resource may return quickly because of light load on the 
          server and proximity between the developer (who is using a powerful device on a fast network) and the 
          server, so that the synchronous call may seem fine. But once deployed, it can cause long, very 
          perceivable freezes for the end-users. The <code>XMLHttpRequest</code> interface does make that option
          available on its <code>open()</code> method and there is broad consensus that it was a bad decision that
          should never be emulated.
        </p>
        <p>
          A context that is not similarly affected by synchronous issues is that of Web Workers (since they run in a 
          separate conceptual thread from the Web application's user interface). In such cases, it can sometimes be useful to
          provide a synchronous variant of an asynchronous interface that would be available solely in a Worker context.
          This is primarily done in order to make development simpler in such contexts and should not be considered 
          required.
        </p>
      </section>
      <section id='numerical-constants'>
        <h2>Don't Use Numerical Constants</h2>
        <p>
          Interfaces regularly require constant identifiers. You have a node and you want to know if it's
          an element or a comment. You have a message and you want to know if it's email or SMS. That much makes
          sense. What does not make sense is insisting on naming these things with numbers when we could name them
          with, you know, names.
        </p>
        <p>
          There are several variants in this bad practice. First, is the lovingly terse approach:
        </p>
        <pre class='example highlight'>
          if (foo.type === 17) doSomething();
        </pre>
        <p>
          Then there is the comment you have to paste every time:
        </p>
        <pre class='example highlight'>
          // check if this of the fungible type
          if (foo.type === 17) doSomething();
        </pre>
        <p>
          Or we can have the uselessly long variant:
        </p>
        <pre class='example highlight'>
          if (foo.type === FooInterface.FUNGIBLE_TYPE) doSomething();
        </pre>
        <p>
          And there's the meh option:
        </p>
        <pre class='example highlight'>
          var isFungible = FooInterface.FUNGIBLE_TYPE;
          // ...
          if (foo.type === isFungible) doSomething();
        </pre>
        <p>
          None of the above is as simple, terse, and self-documenting as:
        </p>
        <pre class='example highlight'>
          if (foo.type === "fungible") doSomething();
        </pre>
        <p>
          We're not in the 1970s, standardising UNIX system calls. Strings are lightweight enough,
          and readable. There is no need to define string constants to support these: just the plain
          strings, defined as such in specification prose, work. In some languages, this can lose
          static verification, but in JavaScript it makes no difference: if you misspell the the
          string you might have equally misspelt the constant, with the same failure.
        </p>
        <p>
          Additionally, interfaces that don't start out by listing a dozen (useless) constants are
          more readable. The only downside to doing away with numerical constants is the negative
          impact it may on occasion have on feature detection. It would however be better to rely
          on other aspects that enable feature detection, since these constants can easily be added
          for a half-baked feature (and frequently have been).
        </p>
      </section>
      <section>
        <h2>Namespacing and Prefixing</h2>
        <p>
          If you are developing functionality for use inside of a Web runtime (but not a browser) that is likely to
          both share code with existing Web projects (typically, libraries like jQuery) and that also plans to
          evolve and integrate improvements to the Web platform on a regular basis, then you should make sure
          that the interfaces and methods you add cannot conflict with ones added to the core platform.
        </p>
        <p>
          For methods and attributes that extend existing interfaces, you should rely on vendor prefixing, i.e. simply
          prefixing your additions with a short string that is your company's or project's name.
        </p>
        <pre class='example highlight'>
          xhr.acmePassiveFTP();
          document.acmeDigitalSignature;
        </pre>
        <p>
          For interfaces that you add, rather than prefixing all of their names which can get tedious, it can
          be simpler to just make them available under your own namespaced object.
        </p>
        <pre class='example highlight'>
          var toaster = new acme.Toaster();
        </pre>
      </section>
    </section>
    <section>
      <h2>WebIDL Constructs</h2>
      <p>
        ...
      </p>
      <section>
        <h2>Using Dictionaries</h2>
        <p>
          ...
        </p>
      </section>
      <section>
        <h2>Interfaces</h2>
        <p>
          ...
        </p>
        <!-- 
          - [Constructor], [ArrayClass], [NamedConstructor]
          - [NoInterfaceObject]
        -->
      </section>
      <section>
        <h2>Constants</h2>
        <p>
          ...
        </p>
      </section>
      <section>
        <h2>Attributes</h2>
        <p>
          ...
        </p>
        <!-- 
          - static
        -->
      </section>
      <section>
        <h2>Methods</h2>
        <p>
          ...
        </p>
      </section>
      <section>
        <h2>Overloading and Union Types</h2>
        <p>
          ...
        </p>
        <!-- 
          - static
        -->
      </section>
      <section>
        <h2>Special Operations</h2>
        <p>
          ...
        </p>
      </section>
      <section>
        <h2>Exceptions</h2>
        <p>
          ...
        </p>
      </section>
      <section>
        <h2>Callbacks</h2>
        <p>
          ...
        </p>
      </section>
      <section>
        <h2>Enums</h2>
        <p>
          ...
        </p>
      </section>
      <section>
        <h2>Typedefs and Implements</h2>
        <p>
          ...
        </p>
      </section>
      <section>
        <h2>Basic Types</h2>
        <p>
          ...
        </p>
        <!-- 
          - [Clamp], [EnforceRange]
          - [TreatNullAs] [TreatUndefinedAs]
        -->
      </section>
      <section>
        <h2>Sequences and Arrays</h2>
        <p>
          ...
        </p>
      </section>
      <section>
        <h2>WebIDL Legacy Features</h2>
        <p>
          The features of WebIDL listed in this section have been specified for the sole purpose of describing
          legacy APIs such as are found in “DOM 0”. It is particularly important that you do not use them unless
          you are trying to document one such API — they must not be used for any kind of new work. The list
          includes:
        </p>
        <p class='issue'>
          Get an actual list.
        </p>
        <!-- 
          - legacy*
          - [LenientThis] 
          - [NamedPropertiesObject] 
          - [TreatNonCallableAsNull] 
        -->
      </section>
    </section>
    <section>
      <h2>Common Patterns</h2>
      <p>
        ...
      </p>
      <section>
        <h2>Ensuring that Feature Detection is Possible</h2>
        <p>
          ...
        </p>
      </section>
      <section>
        <h2>Specifying Callbacks</h2>
        <p>
          Asynchronous method calls require a point of reentry in the form of a callback. There are multiple
          ways of specifying these, none of which is consensually consider the one and only approach.
        </p>
        <p>
          One is <dfn>success/error callback functions</dfn>, as used in [[GEOLOCATION-API]]. It takes the shape of a method
          call that accepts a callback function for success followed by one for errors. There may be arguments
          before the success callback, and the error callback is usually optional.
        </p>
        <pre class='example highlight'>
          navigator.petKitten(
              function() {
                  console.log("kitten is purring");
              },
              function(err) {
                  console.log("kitten hates you, because: " + err);
              }
          );
        </pre>
        <p>
          Downsides of this approach are that it is a little more verbose and does not encourage error handling. It
          also lacks in extensibility since adding new arguments to the method will typically require placing them
          after the optional error handler — making them de facto optional. Likewise, extending it to support not
          just callbacks for success and error but also for other situations that may warrant reporting information
          back (e.g. progress being made) is clumsy at best. Since it is only used in [[GEOLOCATION-API]] it does not
          appear to be a required pattern for consistency.
        </p>
        <p>Another approach is to define new DOM Events that are called when an underlying system changes.</p>
        <pre class='example higlight'>
          window.addEventListener("kittenpurr", function() {
              console.log("kitten is purring");
          }, false);
        </pre>
        <p>On one hand, most developers are quite familiar with DOM Events, and they make it easy to have several handlers for a given event.</p>
        <p>On the other hand, using DOM Events for listening to systems that need specific activation (e.g. powering up) are usually not a good idea: <code>addEventListener</code> is supposed to be free from side effects, and associating activation code with it breaks that promise. The [[DEVICE-ORIENTATION]] specification is as such an <strong>anti-pattern</strong> that should not be replicated. See <a href="http://lists.w3.org/Archives/Public/public-device-apis/2011Nov/0164.html">some discussions on side effects in addEventListener</a>.</p>
        <p>
          Another is <dfn>returning an EventTarget object</dfn>, as pioneered by [[XMLHTTPREQUEST]]. This consists
          in opening a request that returns an object on which event handlers can be registered, then starting
          that request with a specific call.
        </p>
        <pre class='example highlight'>
          var kitpet = navigator.openKittenPetting();

          kitpet.onpurr = function () {
              console.log("kitten is purring");
          };

          kitpet.ondrool = function () {
              console.log("kitten is now drooling");
          };

          kitpet.onviciousbite = function () {
              console.log("kitten bit your hand off");
          };

          kitpet.start();
        </pre>
        <p>
          The approach is the most verbose and does not encourage error handling, but it does have the advantages
          of being trivially extended for greater feedback, and of being familiar to users of [[XMLHTTPREQUEST]]
          (and now [[INDEXEDDB]]). It can, however, feel rather overkill if extensions for additional events does
          not seem likely.
        </p>
        <p>
          Then there are <dfn>NodeJS style callbacks</dfn>. For every asynchronous operation, every callback takes
          as first parameter an error object which is <code>null</code> when the operation was a success, followed
          by as many pieces of information as are needed to capture the success.
        </p>
        <pre class='example highlight'>
          navigator.petKitten(function (err, state) {
              if (err) console.log("kitten mauled your face with extreme prejudice");
              else console.log("kittem manifest joy by " + state);
          });
        </pre>
        <p>
          The primary value in this approach is that it puts errors "right there" where they are likely to be handled.
          Its consistency is also very helpful in creating chains of callbacks, a feature that proves precious
          when multiple callbacks can become nested. The major downside of this approach is that it is currently
          not used in the rest of stack and therefore probably only familiar to NodeJS developers (which granted
          represent a fast-growing proportion of the general web developer population).
        </p>
        <p>
          Finally there are <dfn>promises</dfn>. These are similar to <a>returning an EventTarget object</a> but
          more generic and use a slightly different style.
        </p>
        <pre class='example highlight'>
          var promise = navigator.petKitten();
          promise.then(function () {
              console.log("kitten is purring");
          }).fail(function () {
              console.log("kitten bit your hand off");
          }).run();
        </pre>
        <p>
          There is elegance and flexibility in promises, but to date they are used in no Web specification.
        </p>
      </section>
      <section>
        <h2>Specifying Events</h2>
        <p>
          ...
        </p>
      </section>
    </section>
    <section class='appendix'>
      <h2>Other Sources</h2>
      <p>
        A number of other sources provide information that can be useful in writing specifications. This list
        is by no means complete, suggestions are welcome.
      </p>
      <p>
        Anne maintains a document called <a href='http://wiki.whatwg.org/wiki/Howto_spec'>How To Spec</a> on 
        how to specify certain features of the platform. Some parts of it are tailored to the specific markup
        that is used when processing specifications with Anolis, but the general advice is sound.
      </p>
    </section>
    <section class='appendix'>
      <h2>Acknowledgements</h2>
      <p>
        Many thanks to the following people, in no particular order: Cameron McCormack, Marcos Càceres, 
        Andreas Gal, Rick Waldron.
      </p>
    </section>
  </body>
</html>
